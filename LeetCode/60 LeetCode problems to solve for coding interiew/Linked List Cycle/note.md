# Linked List Cycle

## URL
https://leetcode.com/problems/linked-list-cycle/

## 問題
> リンクトリストの先頭のノード`head`が与えられる。
> 
> 与えられたリンクトリストがサイクル（循環？）があるかどうか、真偽値で返す。

> 「サイクルがある」というのは、`next`ポインタを辿って再度いずれかのノードに到達可能であることを言う。


## 解法

### 1. Hash Tableで辿ったノードを保存する


#### 解説
辿ったノードを全部ハッシュテーブルに突っ込んで、

①`next`が`None`のノードがある場合、サイクルはないので`False`

②リンクトリストを辿るうちに、ハッシュテーブルに存在するノードへ到達したら、サイクルがあるので`True`

PythonやJavaでは`Set()`が使える。


#### 計算量
`n`をリンクトリスト内のノードの総数とする。
- 時間計算量：O(n)
    - 必ず1回すべてのノードを辿る必要がある → 合計n回
    - ハッシュテーブルへの追加はO(1)で可能

- 空間計算量：O(n)
    - 必ずすべてのノードをハッシュテーブルに格納する → 合計n個

### 2. Floyd's Cycle Finding Algorithm

#### 解説

フロイドの循環検出法 - Wikipedia

https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E3%81%AE%E5%BE%AA%E7%92%B0%E6%A4%9C%E5%87%BA%E6%B3%95

もしうさぎとかめが同じコースを走っていたら、

①コースにサイクルがなければ、うさぎが先にゴールする

②コースにサイクルがあれば、うさぎがかめにいずれ追いつく

🐇🐢

リンクトリストを走査するのに使うノードの変数を2つに増やす。

1つはかめ、ノードを1つ1つ確認する。

もう1つはうさぎ、ノードを1つとばしで確認する。

うさぎが`None`になったら（＝ゴールしたら）、サイクルがないため`False`を返す。

うさぎ == かめ になったら（＝うさぎがかめに追いついたら）、サイクルがあるので`True`を返す。

#### 計算量

- 時間計算量：O(n)
    - リンクトリストにサイクルがある場合

        うさぎがゴールしたら（＝リンクトリストを一周したら）終了なのでO(n)
    
    - リンクトリストにサイクルがない場合

        1. かめがサイクルに入る前のことを考える

            かめがサイクルに入る直前、うさぎは既にサイクルの中にいる状態。

            リンクトリストのサイクルになっていない部分の長さを`N`と置く。
        
        2. かめがサイクルに入った後のことを考える

            （かめとうさぎの間の距離）/（かめとうさぎのスピードの差）＝うさぎが追いつくまでにかかる回数

            かめが1つずつ、うさぎが2つずつ進むのでスピードの差は1、

            かめとうさぎの間の距離はその時々だが、最悪のケースではサイクル一周分の長さになる。

            リンクトリストのサイクル部分の長さを`K`と置くと、`K/1=K`となる。
        
        よって、合計`N+K=n`なので、時間計算量はO(n)となる。
    
- 空間計算量：O(1)

    - うさぎとかめの2匹分の変数を用意するだけなので定数、つまりO(n)。
